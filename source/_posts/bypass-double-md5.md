---
title: 双md5碰撞绕过原理及方法
tags: 
- php 
- ctf 
- web
categories: 
- web安全
---



### 记录一次web解题绕过md5()的方法，仅供参考

```php
$a=$_GET['a'];
$b=$_GET['b'];
if((md5($a)=md5($b)) and ($a != $b))
	echo $flag;
else
	echo "nonono!";
```

出现类似要求md5加密后相等且不加密不等的问题便是双md5碰撞。
可以利用PHP中md5函数的特性求解

解法一：0e绕过（科学计数法）
当一个值被md5加密后，其结果以0e开头，则会被当做科学计数法处理，最终会被处理为 0=0的效果，以此绕过。
类似被md5（）加密后的值还有：

```php
240610708
0e462097431906509019562988736854
s878926199a
0e545993274517709034328855841020
s155964671a
0e342768416822451524974117254469
s214587387a
0e848240448830537924465865611904
s214587387a
0e848240448830537924465865611904
s878926199a
0e545993274517709034328855841020
s1091221200a
0e940624217856561557816327384675
s1885207154a
0e509367213418206700842008763514

```

因此构造payload如下：

+ xxx.com/index.php?a='s155964671a'&b='aabC9RqS'



后台会被处理为if(0=0&‘s155964671a’!=‘aabC9RqS’),最终绕过，得到flag。

解法二：数组绕过
md5() 函数不能处理数组，数组都返回 null，md5(a[]) 结果为 null
即payload如下：

+ xxx.com/index.php?a[]=1&b[]=2

如此变为 if(null=null&s[1]!=s[2]),绕过成功，得到flag。